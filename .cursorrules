# OpenAI Platform Learning Portfolio - Cursor Rules

## Project Overview
This is a comprehensive learning portfolio demonstrating OpenAI Platform capabilities for .NET development teams. The project includes multiple sample applications, shared libraries, integrations, and production-ready infrastructure.

## Architecture Principles

### 1. Shared Libraries First
- All OpenAI functionality lives in `shared/OpenAIShared/`
- Common middleware and utilities in `shared/Common/`
- Data models in `shared/Models/`
- Database context in `shared/Data/`
- Always reference shared libraries, never duplicate code

### 2. Service Registration Pattern
- Use `ServiceCollectionExtensions` for all service registration
- Follow dependency injection best practices
- Register services with appropriate lifetimes (Singleton, Scoped, Transient)
- Use `IOptions<T>` for configuration

### 3. API Project Structure
- Each API project follows: `src/{ProjectName}/{ProjectName}.Api/`
- Core logic in: `src/{ProjectName}/{ProjectName}.Core/`
- Controllers should be thin - delegate to services
- Use dependency injection for all dependencies

## Code Style & Standards

### C# Coding Standards
- Use `file-scoped namespaces` (C# 10+)
- Use `nullable reference types` enabled
- Use `implicit usings` enabled
- Prefer `var` for local variables when type is obvious
- Use `record` types for DTOs when appropriate
- Use `init` properties for immutable DTOs

### Naming Conventions
- **Classes**: PascalCase (e.g., `OpenAIClient`, `RequirementsService`)
- **Methods**: PascalCase (e.g., `GetChatCompletionAsync`, `ProcessRequirements`)
- **Properties**: PascalCase (e.g., `ApiKey`, `BaseUrl`)
- **Private fields**: `_camelCase` (e.g., `_logger`, `_httpClient`)
- **Local variables**: camelCase (e.g., `response`, `userStory`)
- **Constants**: PascalCase (e.g., `MaxRetries`, `DefaultTimeout`)
- **Interfaces**: `I` prefix (e.g., `IOpenAIService`)

### Async/Await Patterns
- Always use `async`/`await` for I/O operations
- Method names end with `Async` suffix (e.g., `GetChatCompletionAsync`)
- Use `CancellationToken` parameter for all async methods
- Never use `.Result` or `.Wait()` - always await

### Error Handling
- Use try-catch blocks for expected exceptions
- Log errors with appropriate log levels
- Use `HttpRequestException` for HTTP-related errors
- Include context in error messages
- Use Polly for retry logic and circuit breakers

### Logging
- Use structured logging with Serilog
- Include correlation IDs in logs
- Use appropriate log levels:
  - `LogTrace`: Very detailed debugging
  - `LogDebug`: Debugging information
  - `LogInformation`: General information
  - `LogWarning`: Warning conditions
  - `LogError`: Error conditions with exceptions
  - `LogCritical`: Critical failures

## OpenAI API Best Practices

### 1. Token Management
- Always use `TokenCounter` to estimate tokens before API calls
- Use `CostCalculator` to track costs
- Set appropriate `MaxTokens` to prevent runaway costs
- Monitor token usage with `MetricsService`

### 2. Model Selection
- Use `gpt-4-turbo-preview` for complex tasks
- Use `gpt-3.5-turbo` for simple tasks (cost optimization)
- Use `text-embedding-ada-002` for embeddings
- Use `whisper-1` for audio transcription
- Use `gpt-4-vision-preview` for image analysis

### 3. Prompt Engineering
- Use `PromptBuilder` for structured prompts
- Include system messages for context
- Provide examples when possible
- Be specific and clear in instructions
- Use temperature 0.3-0.7 for most tasks (lower = more deterministic)

### 4. Caching
- Cache embeddings (they don't change)
- Cache similar prompts/responses
- Use `CachingService` for response caching
- Set appropriate cache durations

### 5. Rate Limiting & Retries
- Implement rate limiting middleware
- Use exponential backoff for retries
- Handle `429 Too Many Requests` gracefully
- Use circuit breaker pattern for resilience

## Testing Standards

### Unit Tests
- Test all business logic
- Mock external dependencies (OpenAI API, HTTP clients)
- Use `OpenAIMockHelper` for OpenAI API mocking
- Use FluentAssertions for assertions
- Aim for >80% code coverage

### Integration Tests
- Test API endpoints end-to-end
- Use `WebApplicationFactory` for API testing
- Test with real database (or in-memory for tests)
- Test error scenarios

### Test Organization
- One test class per class under test
- Test file: `{ClassName}Tests.cs`
- Test method naming: `{MethodName}_{Scenario}_{ExpectedResult}`
- Use `[Fact]` for xUnit tests
- Use `[Theory]` with `[InlineData]` for parameterized tests

## API Design Standards

### RESTful APIs
- Use proper HTTP verbs (GET, POST, PUT, DELETE)
- Use resource-based URLs (`/api/user-stories`, `/api/requirements`)
- Return appropriate HTTP status codes:
  - `200 OK`: Success
  - `201 Created`: Resource created
  - `400 Bad Request`: Invalid input
  - `401 Unauthorized`: Authentication required
  - `403 Forbidden`: Authorization failed
  - `404 Not Found`: Resource not found
  - `429 Too Many Requests`: Rate limit exceeded
  - `500 Internal Server Error`: Server error

### Controller Best Practices
- Keep controllers thin - delegate to services
- Use `[ApiController]` attribute
- Use `[Route("api/[controller]")]` for routing
- Use DTOs for request/response models
- Validate input with data annotations or FluentValidation
- Return `ActionResult<T>` or `IActionResult`

### Documentation
- Use XML comments for all public APIs
- Include Swagger/OpenAPI documentation
- Document request/response examples
- Document error responses

## Middleware & Pipeline

### Middleware Order (Critical!)
1. Correlation ID middleware (first)
2. Request/Response logging
3. Response compression
4. CORS
5. Rate limiting
6. HTTPS redirection
7. Authentication
8. Authorization
9. Controllers/Endpoints

### Use Common Middleware
- Always use `app.UseCommonMiddleware()` extension
- Add custom middleware only when necessary
- Ensure middleware order is correct

## Configuration Management

### appsettings.json Structure
```json
{
  "OpenAI": {
    "ApiKey": "...",
    "BaseUrl": "https://api.openai.com/v1",
    "DefaultModel": "gpt-4-turbo-preview",
    "MaxRetries": 3,
    "TimeoutSeconds": 60
  },
  "ConnectionStrings": {
    "DefaultConnection": "..."
  },
  "Jwt": {
    "SecretKey": "...",
    "Issuer": "OpenAIPlatform",
    "Audience": "OpenAIPlatform",
    "ExpirationMinutes": "60"
  },
  "Cors": {
    "AllowedOrigins": ["http://localhost:3000"]
  }
}
```

### Secrets Management
- Never commit secrets to git
- Use environment variables for production
- Use Azure Key Vault or similar for production secrets
- Use User Secrets for local development

## Database Standards

### Entity Framework Core
- Use `ApplicationDbContext` for all database operations
- Create migrations for schema changes
- Use async methods for all database operations
- Include related data with `.Include()`
- Use transactions for multi-step operations

### Migration Commands
```bash
# Add migration
dotnet ef migrations add MigrationName --project shared/Data --startup-project src/[Project]/[Project].Api

# Update database
dotnet ef database update --project shared/Data --startup-project src/[Project]/[Project].Api
```

## Docker & Deployment

### Dockerfile Best Practices
- Use multi-stage builds
- Use .NET 8.0 runtime image
- Copy only necessary files
- Set appropriate health checks
- Use non-root user in production

### Docker Compose
- Use environment variables for configuration
- Set up health checks for all services
- Use volumes for persistent data
- Document all services

## Security Best Practices

### Authentication & Authorization
- Use API key authentication for simple APIs
- Use JWT for user-based authentication
- Always validate tokens
- Use role-based authorization when needed
- Never expose API keys in client-side code

### Input Validation
- Validate all user input
- Sanitize input before processing
- Use parameterized queries (EF Core handles this)
- Validate file uploads

### API Security
- Use HTTPS in production
- Implement rate limiting
- Use CORS appropriately
- Log security events
- Monitor for suspicious activity

## Performance Best Practices

### Caching
- Cache expensive operations
- Use appropriate cache durations
- Invalidate cache when data changes
- Monitor cache hit rates

### Async Operations
- Use async/await for all I/O
- Don't block async calls
- Use `ConfigureAwait(false)` in libraries
- Use parallel processing when appropriate

### Database
- Use indexes for frequently queried fields
- Avoid N+1 queries (use `.Include()`)
- Use pagination for large result sets
- Monitor slow queries

## Documentation Standards

### Code Documentation
- XML comments for all public APIs
- Include parameter descriptions
- Include return value descriptions
- Include exception documentation
- Include usage examples

### README Files
- Include project overview
- Include setup instructions
- Include usage examples
- Include configuration guide
- Include troubleshooting section

### API Documentation
- Use Swagger/OpenAPI
- Include request/response examples
- Document error responses
- Document authentication requirements

## Git Best Practices

### Commit Messages
- Use descriptive commit messages
- Start with verb (Add, Fix, Update, Remove)
- Include context (e.g., "Add streaming support to Requirements API")
- Reference issues when applicable

### Branching
- Use `main` branch for production-ready code
- Create feature branches for new features
- Use descriptive branch names
- Keep branches up to date

## Code Review Checklist

Before submitting code:
- [ ] Code follows naming conventions
- [ ] All public APIs have XML comments
- [ ] Unit tests added/updated
- [ ] Integration tests pass
- [ ] No compiler warnings
- [ ] Logging added where appropriate
- [ ] Error handling implemented
- [ ] Configuration externalized
- [ ] Documentation updated
- [ ] Security considerations addressed

## Common Patterns

### Service Pattern
```csharp
public class MyService
{
    private readonly ILogger<MyService> _logger;
    private readonly OpenAIClient _openAIClient;

    public MyService(ILogger<MyService> logger, OpenAIClient openAIClient)
    {
        _logger = logger;
        _openAIClient = openAIClient;
    }

    public async Task<Result> ProcessAsync(string input, CancellationToken cancellationToken = default)
    {
        _logger.LogInformation("Processing input: {Input}", input);
        
        try
        {
            // Process...
            return result;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error processing input: {Input}", input);
            throw;
        }
    }
}
```

### Controller Pattern
```csharp
[ApiController]
[Route("api/[controller]")]
public class MyController : ControllerBase
{
    private readonly MyService _service;
    private readonly ILogger<MyController> _logger;

    public MyController(MyService service, ILogger<MyController> logger)
    {
        _service = service;
        _logger = logger;
    }

    [HttpPost]
    public async Task<ActionResult<Result>> Process([FromBody] Request request, CancellationToken cancellationToken)
    {
        var result = await _service.ProcessAsync(request.Input, cancellationToken);
        return Ok(result);
    }
}
```

## OpenAI-Specific Guidelines

### Always Include
- Token counting before API calls
- Cost estimation
- Error handling for rate limits
- Logging of API calls
- Metrics tracking

### Never Include
- Hardcoded API keys
- API keys in logs
- Unvalidated user input in prompts
- Sensitive data in prompts

## Project-Specific Rules

### File Organization
- Shared libraries: `shared/`
- Source projects: `src/`
- Tests: `tests/`
- Documentation: `docs/`
- Samples: `samples/`

### Dependencies
- Prefer built-in .NET libraries
- Use well-maintained NuGet packages
- Keep dependencies up to date
- Document why external dependencies are needed

### Integration Points
- Confluence: Use `ConfluenceIntegration`
- Jira: Use `JiraIntegration` or `EnhancedJiraIntegration`
- GitHub: Use `GitHubIntegration`
- Slack: Use `SlackIntegration`

## When Adding New Features

1. **Plan**: Document the feature in `docs/improvements/`
2. **Design**: Create service/controller structure
3. **Implement**: Write code following standards
4. **Test**: Add unit and integration tests
5. **Document**: Update README and API docs
6. **Review**: Self-review before committing

## Questions to Ask

Before implementing:
- Is this functionality already in a shared library?
- Can this be reused by other projects?
- Are there tests for this?
- Is this documented?
- Is this secure?
- Is this performant?
- Is this maintainable?
